#!/usr/bin/env python3
"""
Script de test am√©lior√© pour diagnostiquer le probl√®me de timing des messages WebSocket Monte Carlo
"""

import asyncio
import json
import time
import requests
import websockets
from datetime import datetime
from typing import Optional, Dict, Any
import signal
import sys
import uuid
import random

# Configuration
API_BASE_URL = "http://localhost:8000/api/v1"
WS_BASE_URL = "ws://localhost:8000/api/v1"

# Donn√©es de test avec plus de runs pour voir la progression
TEST_PAYLOAD = {
    "end_date": "2022-03-23",
    "gaussian_scale": 1,
    "initial_capital": 10000,
    "method": "bootstrap",
    "num_runs": 100,  # Plus de runs pour mieux observer le timing
    "priority": 2,
    "sample_fraction": 1,
    "start_date": "2016-01-21",
    "strategy_params": {
        "sma_long": 30,
        "sma_short": 10
    },
    "symbol": "amzn"
}

class TimingDiagnosticTester:
    def __init__(self):
        self.job_id: Optional[str] = None
        self.ws_connection: Optional[websockets.WebSocketServerProtocol] = None
        self.progress_data = {
            "status": "",
            "progress": 0.0,
            "current_run": 0,
            "total_runs": 0,
            "eta_seconds": None
        }
        self.completed = False
        self.failed = False
        self.ws_task: Optional[asyncio.Task] = None
        self.progress_messages = []
        self.start_time = None
        self.job_submission_time = None
        self.ws_connection_time = None
        self.first_message_time = None
        self.job_start_time = None
        
    def log(self, message: str, level: str = "INFO"):
        """Log avec timestamp pr√©cis"""
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        elapsed = ""
        if self.start_time:
            elapsed_sec = time.time() - self.start_time
            elapsed = f" (+{elapsed_sec:.3f}s)"
        print(f"[{timestamp}{elapsed}] [{level}] {message}")
        
    def submit_monte_carlo_job(self) -> bool:
        """Soumet un job Monte Carlo via l'API REST"""
        try:
            # Cr√©er un payload unique
            test_payload = TEST_PAYLOAD.copy()
            unique_id = str(uuid.uuid4())[:8]
            timestamp_ms = int(time.time() * 1000)
            
            # Modifier plusieurs param√®tres pour garantir l'unicit√©
            test_payload["initial_capital"] = TEST_PAYLOAD["initial_capital"] + random.randint(1000, 9999)
            test_payload["gaussian_scale"] = round(random.uniform(0.5, 2.0), 3)
            test_payload["num_runs"] = TEST_PAYLOAD["num_runs"] + random.randint(1, 50)
            test_payload["sample_fraction"] = round(random.uniform(0.8, 1.0), 3)
            
            # Ajouter l'ID unique dans les param√®tres de strat√©gie
            test_payload["strategy_params"]["unique_id"] = unique_id
            
            self.log("üöÄ Soumission du job Monte Carlo...")
            self.log(f"Payload: num_runs={test_payload['num_runs']}, unique_id={unique_id}")
            
            self.job_submission_time = time.time()
            
            response = requests.post(
                f"{API_BASE_URL}/monte-carlo/jobs",
                json=test_payload,
                headers={"Content-Type": "application/json"},
                timeout=30
            )
            
            if response.status_code in [200, 201]:
                data = response.json()
                self.job_id = data.get("job_id")
                submission_duration = time.time() - self.job_submission_time
                self.log(f"‚úÖ Job cr√©√© avec succ√®s! ID: {self.job_id} (dur√©e: {submission_duration:.3f}s)")
                self.log(f"Status initial: {data.get('status', 'unknown')}")
                return True
            else:
                self.log(f"‚ùå Erreur lors de la cr√©ation du job: {response.status_code}", "ERROR")
                self.log(f"Response: {response.text}", "ERROR")
                return False
                
        except Exception as e:
            self.log(f"‚ùå Exception lors de la soumission: {str(e)}", "ERROR")
            return False
    
    async def check_job_status_immediately(self):
        """V√©rifie le statut du job imm√©diatement apr√®s soumission"""
        if not self.job_id:
            return
            
        try:
            response = requests.get(
                f"{API_BASE_URL}/monte-carlo/jobs/{self.job_id}",
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                check_time = time.time() - self.job_submission_time
                self.log(f"üìä Statut imm√©diat (+{check_time:.3f}s): {data.get('status', 'unknown')}")
                self.log(f"   Progress: {data.get('progress', 0) * 100:.1f}%")
                self.log(f"   Current/Total runs: {data.get('current_run', 0)}/{data.get('total_runs', 0)}")
                return data
            else:
                self.log(f"‚ùå Erreur statut imm√©diat: {response.status_code}", "ERROR")
                
        except Exception as e:
            self.log(f"‚ùå Exception statut imm√©diat: {e}", "ERROR")
    
    async def connect_websocket_with_timing(self):
        """Se connecte au WebSocket avec diagnostic de timing d√©taill√©"""
        if not self.job_id:
            self.log("‚ùå Pas de job_id pour la connexion WebSocket", "ERROR")
            return
            
        ws_url = f"{WS_BASE_URL}/monte-carlo/jobs/{self.job_id}/progress"
        self.log(f"üîå Tentative de connexion WebSocket: {ws_url}")
        
        connection_start = time.time()
        
        try:
            async with websockets.connect(
                ws_url,
                ping_interval=20,
                ping_timeout=10,
                close_timeout=10
            ) as websocket:
                self.ws_connection = websocket
                self.ws_connection_time = time.time()
                connection_duration = self.ws_connection_time - connection_start
                ws_delay = self.ws_connection_time - self.job_submission_time
                
                self.log(f"‚úÖ WebSocket connect√©! (dur√©e connexion: {connection_duration:.3f}s, d√©lai depuis soumission: {ws_delay:.3f}s)")
                
                message_count = 0
                
                # √âcouter les messages avec timing d√©taill√©
                async for message in websocket:
                    try:
                        message_received_time = time.time()
                        data = json.loads(message)
                        message_count += 1
                        
                        # Marquer le premier message
                        if self.first_message_time is None:
                            self.first_message_time = message_received_time
                            first_msg_delay = self.first_message_time - self.job_submission_time
                            ws_to_first_msg = self.first_message_time - self.ws_connection_time
                            self.log(f"üéØ PREMIER MESSAGE RE√áU! (d√©lai depuis soumission: {first_msg_delay:.3f}s, depuis connexion WS: {ws_to_first_msg:.3f}s)")
                        
                        await self.handle_progress_message_with_timing(data, message_count, message_received_time)
                        
                        # V√©rifier si le job est termin√©
                        status = str(data.get("status", "")).upper()
                        if any(term in status for term in ["COMPLETED", "FAILED", "CANCELLED"]):
                            completion_time = time.time()
                            total_duration = completion_time - self.job_submission_time
                            self.log(f"üèÅ Job termin√© avec le statut: {status} (dur√©e totale: {total_duration:.3f}s)")
                            
                            if "COMPLETED" in status:
                                self.completed = True
                                self.log("üéâ Monte Carlo termin√© avec succ√®s!")
                            else:
                                self.failed = True
                                self.log("üí• Monte Carlo a √©chou√©!")
                            break
                            
                    except json.JSONDecodeError as e:
                        self.log(f"‚ùå Erreur de parsing JSON: {e}", "ERROR")
                    except Exception as e:
                        self.log(f"‚ùå Erreur lors du traitement du message: {e}", "ERROR")
                        
        except websockets.exceptions.ConnectionClosed:
            self.log("üîå Connexion WebSocket ferm√©e")
        except websockets.exceptions.InvalidURI:
            self.log(f"‚ùå URI WebSocket invalide: {ws_url}", "ERROR")
        except Exception as e:
            self.log(f"‚ùå Erreur WebSocket: {e}", "ERROR")
            self.failed = True
    
    async def handle_progress_message_with_timing(self, data: Dict[str, Any], message_count: int, received_time: float):
        """Traite un message de progression avec analyse de timing"""
        # Stocker le message avec timing
        self.progress_messages.append({
            "timestamp": received_time,
            "message_count": message_count,
            "data": data.copy()
        })
        
        # D√©tecter le message d'accus√© de r√©ception imm√©diat
        if data.get("status") == "connecting":
            msg_delay = received_time - self.job_submission_time
            self.log(f"üîó Msg#{message_count} (+{msg_delay:.3f}s): CONNEXION - {data.get('message', 'Connexion √©tablie')}")
            return
        
        # Mettre √† jour les donn√©es de progression
        self.progress_data.update({
            "status": str(data.get("status", "")),
            "progress": float(data.get("progress", 0.0)),
            "current_run": int(data.get("current_run", 0)),
            "total_runs": int(data.get("total_runs", 0)),
            "eta_seconds": data.get("eta_seconds")
        })
        
        # Calculer les timings
        msg_delay = received_time - self.job_submission_time
        progress_percent = round(self.progress_data["progress"] * 100, 1)
        
        # D√©tecter le d√©but du traitement (quand current_run > 0 pour la premi√®re fois)
        if self.job_start_time is None and self.progress_data["current_run"] > 0:
            self.job_start_time = received_time
            job_start_delay = self.job_start_time - self.job_submission_time
            self.log(f"üèÉ D√âBUT DU TRAITEMENT D√âTECT√â! (d√©lai: {job_start_delay:.3f}s)")
        
        # Log de progression avec timing
        status = self.progress_data["status"]
        current = self.progress_data["current_run"]
        total = self.progress_data["total_runs"]
        
        # Formater l'ETA
        eta_str = ""
        if self.progress_data["eta_seconds"] is not None:
            eta_sec = int(self.progress_data["eta_seconds"])
            if eta_sec < 60:
                eta_str = f" (ETA: {eta_sec}s)"
            else:
                eta_min = eta_sec // 60
                eta_sec_rem = eta_sec % 60
                eta_str = f" (ETA: {eta_min}m {eta_sec_rem}s)"
        
        if current > 0 and total > 0:
            # Calculer la vitesse si le traitement a commenc√©
            if self.job_start_time:
                processing_time = received_time - self.job_start_time
                speed = current / processing_time if processing_time > 0 else 0
                speed_str = f" ({speed:.1f} runs/s)" if speed > 0 else ""
            else:
                speed_str = ""
            
            self.log(f"üìä Msg#{message_count} (+{msg_delay:.3f}s): {status} - {current}/{total} runs ({progress_percent}%){speed_str}{eta_str}")
        else:
            self.log(f"üìä Msg#{message_count} (+{msg_delay:.3f}s): {status} - {progress_percent}%{eta_str}")
            
        # Log sp√©cial pour les messages probl√©matiques
        if current == 0 and total == 0 and message_count > 1:
            self.log(f"‚ö†Ô∏è  Message avec 0/0 runs d√©tect√©! Contenu: {data}", "WARNING")
    
    async def monitor_job_status_parallel(self):
        """Surveille le statut du job en parall√®le via l'API REST"""
        if not self.job_id:
            return
            
        self.log("üîç D√©marrage de la surveillance parall√®le via API REST...")
        
        last_status = None
        check_count = 0
        
        while not self.completed and not self.failed:
            try:
                check_count += 1
                check_time = time.time()
                
                response = requests.get(
                    f"{API_BASE_URL}/monte-carlo/jobs/{self.job_id}",
                    timeout=5
                )
                
                if response.status_code == 200:
                    data = response.json()
                    current_status = data.get("status", "unknown")
                    
                    # Log seulement si le statut change
                    if current_status != last_status:
                        check_delay = check_time - self.job_submission_time
                        self.log(f"üîÑ API Check#{check_count} (+{check_delay:.3f}s): Status chang√© vers '{current_status}'")
                        self.log(f"   Progress: {data.get('progress', 0) * 100:.1f}%")
                        self.log(f"   Runs: {data.get('current_run', 0)}/{data.get('total_runs', 0)}")
                        last_status = current_status
                    
                    # Arr√™ter si termin√©
                    if current_status in ["completed", "failed", "cancelled"]:
                        break
                        
                await asyncio.sleep(2)  # V√©rifier toutes les 2 secondes
                
            except Exception as e:
                self.log(f"‚ùå Erreur surveillance API: {e}", "ERROR")
                await asyncio.sleep(2)
    
    def analyze_timing_issues(self):
        """Analyse les probl√®mes de timing d√©tect√©s"""
        self.log("üî¨ ANALYSE DES PROBL√àMES DE TIMING:")
        self.log("=" * 60)
        
        if not self.progress_messages:
            self.log("‚ö†Ô∏è  PROBL√àME MAJEUR: Aucun message WebSocket re√ßu!", "ERROR")
            return
            
        # Analyser les d√©lais
        if self.first_message_time:
            first_msg_delay = self.first_message_time - self.job_submission_time
            self.log(f"üìä D√©lai premier message WebSocket: {first_msg_delay:.3f}s")
            
            if first_msg_delay > 5.0:
                self.log("‚ö†Ô∏è  PROBL√àME: D√©lai > 5s pour le premier message!", "WARNING")
        
        if self.job_start_time:
            job_start_delay = self.job_start_time - self.job_submission_time
            self.log(f"üìä D√©lai d√©but traitement: {job_start_delay:.3f}s")
            
            if job_start_delay > 10.0:
                self.log("‚ö†Ô∏è  PROBL√àME: D√©lai > 10s pour d√©marrer le traitement!", "WARNING")
        
        # Analyser les messages
        first_msg = self.progress_messages[0]["data"]
        self.log(f"üìä Premier message: {first_msg}")
        
        if first_msg.get("current_run", 0) == 0 and first_msg.get("total_runs", 0) == 0:
            self.log("‚ö†Ô∏è  PROBL√àME: Premier message avec 0/0 runs!", "WARNING")
        
        # Compter les messages avec 0/0 runs
        zero_messages = [msg for msg in self.progress_messages if msg["data"].get("current_run", 0) == 0 and msg["data"].get("total_runs", 0) == 0]
        if zero_messages:
            self.log(f"‚ö†Ô∏è  PROBL√àME: {len(zero_messages)} messages avec 0/0 runs d√©tect√©s!", "WARNING")
        
        self.log(f"üìä Total messages re√ßus: {len(self.progress_messages)}")
        
        if len(self.progress_messages) > 1:
            duration = self.progress_messages[-1]["timestamp"] - self.progress_messages[0]["timestamp"]
            self.log(f"üìä Dur√©e de progression WebSocket: {duration:.3f}s")
    
    async def run_diagnostic_test(self):
        """Ex√©cute le test de diagnostic complet"""
        self.log("üéØ D√âMARRAGE DU TEST DE DIAGNOSTIC TIMING")
        self.log("=" * 70)
        
        self.start_time = time.time()
        
        # 1. Soumettre le job
        if not self.submit_monte_carlo_job():
            self.log("‚ùå √âchec de la soumission du job", "ERROR")
            return False
        
        # 2. V√©rifier le statut imm√©diatement
        await self.check_job_status_immediately()
        
        # 3. D√©marrer la surveillance parall√®le
        monitor_task = asyncio.create_task(self.monitor_job_status_parallel())
        
        # 4. Attendre un court d√©lai puis se connecter au WebSocket
        self.log("‚è≥ Attente de 1 seconde avant connexion WebSocket...")
        await asyncio.sleep(1)
        
        # 5. Se connecter au WebSocket
        await self.connect_websocket_with_timing()
        
        # 6. Arr√™ter la surveillance
        monitor_task.cancel()
        
        # 7. Analyser les probl√®mes de timing
        self.analyze_timing_issues()
        
        # 8. R√©sum√©
        self.log("=" * 70)
        total_time = time.time() - self.start_time
        self.log(f"‚è±Ô∏è  Temps total du test: {total_time:.3f}s")
        
        if self.completed:
            self.log("‚úÖ TEST R√âUSSI: Job compl√©t√© avec succ√®s!")
            return True
        elif self.failed:
            self.log("‚ùå TEST √âCHOU√â: Job a √©chou√©!")
            return False
        else:
            self.log("‚ö†Ô∏è  TEST INCOMPLET: Statut final incertain")
            return False

def signal_handler(signum, frame):
    """Gestionnaire de signal pour arr√™t propre"""
    print("\nüõë Arr√™t du test demand√©...")
    sys.exit(0)

async def main():
    """Fonction principale"""
    signal.signal(signal.SIGINT, signal_handler)
    
    tester = TimingDiagnosticTester()
    
    try:
        success = await tester.run_diagnostic_test()
        if success:
            print("\nüéâ Test de diagnostic termin√© avec succ√®s!")
            sys.exit(0)
        else:
            print("\nüí• Test de diagnostic √©chou√©!")
            sys.exit(1)
            
    except KeyboardInterrupt:
        print("\nüõë Test interrompu par l'utilisateur")
        sys.exit(1)
    except Exception as e:
        print(f"\nüí• Erreur inattendue: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    print("üß™ Test de diagnostic timing WebSocket Monte Carlo")
    print("Ce test analyse pr√©cis√©ment les d√©lais de r√©ception des messages")
    print("Appuyez sur Ctrl+C pour arr√™ter")
    print()
    
    # V√©rifier que les d√©pendances sont disponibles
    try:
        import websockets
        import requests
    except ImportError as e:
        print(f"‚ùå D√©pendance manquante: {e}")
        print("Installez avec: pip install websockets requests")
        sys.exit(1)
    
    # Lancer le test
    asyncio.run(main())